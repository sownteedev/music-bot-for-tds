// Polyfill for ReadableStream and File if not available
if (typeof globalThis.ReadableStream === 'undefined') {
    const { ReadableStream } = require('web-streams-polyfill/ponyfill');
    globalThis.ReadableStream = ReadableStream;
}

if (typeof globalThis.File === 'undefined') {
    try {
        const { File } = require('undici');
        globalThis.File = File;
    } catch (e) {
        // Fallback File implementation
        globalThis.File = class File {
            constructor(chunks, name, options = {}) {
                this.name = name;
                this.type = options.type || '';
                this.lastModified = options.lastModified || Date.now();
                this.chunks = chunks;
            }
        };
    }
}

const { Client, GatewayIntentBits, EmbedBuilder } = require('discord.js');
const { DisTube } = require('distube');
const { YouTubePlugin } = require('@distube/youtube');
const { SpotifyPlugin } = require('@distube/spotify');
const fs = require('fs');
const http = require('http');

// ƒê·ªçc config t·ª´ environment ho·∫∑c file
let config;
if (process.env.DISCORD_TOKEN) {
    // Production: ƒë·ªçc t·ª´ environment variables
    config = {
        token: process.env.DISCORD_TOKEN,
        prefix: process.env.PREFIX || '!',
        clientId: process.env.CLIENT_ID || ''
    };
    console.log('üì° Using environment variables for config');
} else {
    // Development: ƒë·ªçc t·ª´ file config.json
    try {
        config = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
        console.log('üìÅ Using config.json file');
    } catch (error) {
        console.error('‚ùå Kh√¥ng t√¨m th·∫•y file config.json! Vui l√≤ng t·∫°o file config.json t·ª´ config.example.json');
        process.exit(1);
    }
}

// T·∫°o client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// T·∫°o DisTube instance v·ªõi YouTube v√† Spotify plugins
const distube = new DisTube(client, {
    plugins: [
        new YouTubePlugin(),
        new SpotifyPlugin()
    ],
    ffmpeg: {
        path: require('ffmpeg-static')
    },
    ytdlOptions: {
        quality: 'highestaudio',
        filter: 'audioonly',
        dlChunkSize: 0,
        highWaterMark: 1 << 25
    }
});

// H√†m ki·ªÉm tra URL YouTube
function isValidYouTubeUrl(url) {
    const regex = /^(https?\:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/;
    return regex.test(url);
}

// H√†m ki·ªÉm tra URL Spotify
function isValidSpotifyUrl(url) {
    const regex = /^(https?\:\/\/)?(open\.)?spotify\.com\/(track|album|playlist|artist)\/.+/;
    return regex.test(url);
}

// H√†m nh·∫≠n di·ªán lo·∫°i URL
function getUrlType(url) {
    if (isValidYouTubeUrl(url)) return 'YouTube';
    if (isValidSpotifyUrl(url)) return 'Spotify';
    return 'Unknown';
}

// Event khi bot s·∫µn s√†ng
client.once('ready', () => {
    console.log(`‚úÖ Bot ƒë√£ s·∫µn s√†ng! ƒêƒÉng nh·∫≠p v·ªõi t√™n: ${client.user.tag}`);
    client.user.setActivity('üéµ YouTube & Spotify Music', { type: 'LISTENING' });
});

// DisTube Events
distube
    .on('playSong', (queue, song) => {
        console.log(`üéµ Playing: ${song.name}`);
        console.log(`Voice channel: ${queue.voiceChannel?.name}`);
        console.log(`Connection state: ${queue.voice?.connection?.state?.status}`);
        
        // Auto shuffle logic - when queue restarts and auto shuffle is enabled
        if (queue.autoShuffle && queue.repeatMode === 2 && queue.songs.indexOf(song) === 0 && queue.songs.length > 1) {
            // Shuffle when starting the queue again (first song plays)
            setTimeout(() => {
                if (queue.songs.length > 1) {
                    queue.shuffle();
                    queue.textChannel.send('üîÄ **Auto shuffle:** ƒê√£ tr·ªôn l·∫°i queue cho v√≤ng l·∫∑p m·ªõi!');
                }
            }, 2000); // Delay 2s ƒë·ªÉ tr√°nh conflict
        }

        const embed = new EmbedBuilder()
            .setTitle('üéµ ƒêang ph√°t')
            .setDescription(`**${song.name}**`)
            .setColor('#00ff00')
            .setThumbnail(song.thumbnail)
            .addFields(
                { name: 'Th·ªùi l∆∞·ª£ng', value: song.formattedDuration, inline: true },
                { name: 'Ng∆∞·ªùi y√™u c·∫ßu', value: song.user.toString(), inline: true },
                { name: 'Views', value: song.views?.toLocaleString() || 'N/A', inline: true }
            )
            .setURL(song.url);

        // Add repeat and shuffle status if enabled
        if (queue.repeatMode > 0 || queue.autoShuffle) {
            const statusTexts = [];
            if (queue.repeatMode === 1) statusTexts.push('üîÅ Repeat Song');
            if (queue.repeatMode === 2) statusTexts.push('üîÅ Repeat Queue');
            if (queue.autoShuffle) statusTexts.push('üîÄ Auto Shuffle');
            
            if (statusTexts.length > 0) {
                embed.addFields({ name: 'Tr·∫°ng th√°i', value: statusTexts.join(' ‚Ä¢ '), inline: false });
            }
        }

        queue.textChannel.send({ embeds: [embed] });
    })
    .on('addSong', (queue, song) => {
        const embed = new EmbedBuilder()
            .setTitle('‚úÖ ƒê√£ th√™m v√†o queue')
            .setDescription(`**${song.name}**`)
            .setColor('#0099ff')
            .setThumbnail(song.thumbnail)
            .addFields(
                { name: 'Th·ªùi l∆∞·ª£ng', value: song.formattedDuration, inline: true },
                { name: 'V·ªã tr√≠ trong queue', value: `${queue.songs.length}`, inline: true },
                { name: 'Ng∆∞·ªùi y√™u c·∫ßu', value: song.user.toString(), inline: true }
            )
            .setURL(song.url);

        queue.textChannel.send({ embeds: [embed] });
    })
    .on('addList', (queue, playlist) => {
        const embed = new EmbedBuilder()
            .setTitle('üìù ƒê√£ th√™m playlist')
            .setDescription(`**${playlist.name}**`)
            .setColor('#1db954')
            .setThumbnail(playlist.thumbnail)
            .addFields(
                { name: 'S·ªë b√†i h√°t', value: `${playlist.songs.length}`, inline: true },
                { name: 'Ng∆∞·ªùi y√™u c·∫ßu', value: playlist.user.toString(), inline: true },
                { name: 'Ngu·ªìn', value: playlist.source || 'Unknown', inline: true }
            )
            .setURL(playlist.url);

        queue.textChannel.send({ embeds: [embed] });
    })
    .on('error', (channel, error) => {
        console.error('DisTube Error:', error);
        if (channel) {
            channel.send('‚ùå C√≥ l·ªói x·∫£y ra khi ph√°t nh·∫°c! Vui l√≤ng th·ª≠ l·∫°i.');
        }
    })
    .on('empty', (queue) => {
        queue.textChannel.send('‚èπÔ∏è Voice channel tr·ªëng, bot ƒë√£ r·ªùi kh·ªèi channel!');
    })
    .on('finish', (queue) => {
        queue.textChannel.send('üé∂ Queue ƒë√£ h·∫øt! Bot s·∫Ω r·ªùi voice channel.');
    })
    .on('disconnect', (queue) => {
        queue.textChannel.send('‚èπÔ∏è Bot ƒë√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi voice channel!');
    })
    .on('noRelated', (queue) => {
        queue.textChannel.send('üîç Kh√¥ng t√¨m th·∫•y b√†i h√°t li√™n quan!');
    });

// Event x·ª≠ l√Ω tin nh·∫Øn
client.on('messageCreate', async (message) => {
    // B·ªè qua tin nh·∫Øn t·ª´ bot
    if (message.author.bot) return;
    
    // Ki·ªÉm tra prefix
    if (!message.content.startsWith(config.prefix)) return;

    const args = message.content.slice(config.prefix.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();

    // Ki·ªÉm tra xem user c√≥ trong voice channel kh√¥ng (cho c√°c l·ªánh c·∫ßn voice)
    const voiceCommands = ['play', 'p'];
    if (voiceCommands.includes(command)) {
        const voiceChannel = message.member.voice.channel;
        if (!voiceChannel) {
            return message.reply('‚ùå B·∫°n ph·∫£i v√†o voice channel tr∆∞·ªõc!');
        }
    }

    switch (command) {
        case 'play':
        case 'p':
            if (!args[0]) {
                return message.reply('‚ùå Vui l√≤ng cung c·∫•p URL (YouTube/Spotify) ho·∫∑c t√™n b√†i h√°t!');
            }

            const query = args.join(' ');
            
            // Hi·ªÉn th·ªã th√¥ng b√°o ƒëang x·ª≠ l√Ω cho Spotify
            let processingMessage;
            if (isValidSpotifyUrl(query)) {
                processingMessage = await message.reply('üéµ ƒêang x·ª≠ l√Ω Spotify URL...');
            }
            
            try {
                await distube.play(message.member.voice.channel, query, {
                    member: message.member,
                    textChannel: message.channel,
                    message
                });
                
                // X√≥a th√¥ng b√°o ƒëang x·ª≠ l√Ω n·∫øu c√≥
                if (processingMessage) {
                    processingMessage.delete().catch(() => {});
                }
            } catch (error) {
                console.error('Play Error:', error);
                
                // X√≥a th√¥ng b√°o ƒëang x·ª≠ l√Ω n·∫øu c√≥
                if (processingMessage) {
                    processingMessage.delete().catch(() => {});
                }
                
                const urlType = getUrlType(query);
                let errorMsg = '‚ùå Kh√¥ng th·ªÉ ph√°t nh·∫°c! ';
                
                if (urlType === 'Spotify') {
                    errorMsg += 'Ki·ªÉm tra l·∫°i Spotify URL ho·∫∑c th·ª≠ URL kh√°c.';
                } else if (urlType === 'YouTube') {
                    errorMsg += 'Ki·ªÉm tra l·∫°i YouTube URL ho·∫∑c th·ª≠ URL kh√°c.';
                } else {
                    errorMsg += 'Vui l√≤ng ki·ªÉm tra l·∫°i URL ho·∫∑c th·ª≠ t√¨m ki·∫øm b√†i kh√°c.';
                }
                
                message.reply(errorMsg);
            }
            break;

        case 'skip':
        case 's':
            const queue = distube.getQueue(message.guild.id);
            if (!queue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            try {
                await distube.skip(message.guild.id);
                message.reply('‚è≠Ô∏è ƒê√£ skip b√†i h√°t!');
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ skip b√†i h√°t!');
            }
            break;

        case 'stop':
            const stopQueue = distube.getQueue(message.guild.id);
            if (!stopQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            try {
                await distube.stop(message.guild.id);
                message.reply('‚èπÔ∏è ƒê√£ d·ª´ng ph√°t nh·∫°c v√† x√≥a queue!');
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ d·ª´ng ph√°t nh·∫°c!');
            }
            break;

        case 'queue':
        case 'q':
            const queueList = distube.getQueue(message.guild.id);
            if (!queueList) {
                return message.reply('‚ùå Queue tr·ªëng!');
            }

            const songs = queueList.songs;
            let queueText = '';
            
            // B√†i ƒëang ph√°t
            if (songs[0]) {
                queueText += `**üéµ ƒêang ph√°t:**\n${songs[0].name} - \`${songs[0].formattedDuration}\`\n\n`;
            }

            // Queue
            if (songs.length > 1) {
                queueText += '**üìù Queue:**\n';
                const queueSongs = songs.slice(1, 11); // Hi·ªÉn th·ªã t·ªëi ƒëa 10 b√†i
                queueSongs.forEach((song, index) => {
                    queueText += `${index + 1}. ${song.name} - \`${song.formattedDuration}\`\n`;
                });
                
                if (songs.length > 11) {
                    queueText += `\n*...v√† ${songs.length - 11} b√†i kh√°c*`;
                }
            }

            const queueEmbed = new EmbedBuilder()
                .setTitle('üéµ Music Queue')
                .setDescription(queueText || 'Queue tr·ªëng')
                .setColor('#0099ff')
                .addFields(
                    { name: 'T·ªïng s·ªë b√†i', value: `${songs.length}`, inline: true },
                    { name: 'T·ªïng th·ªùi l∆∞·ª£ng', value: queueList.formattedDuration, inline: true }
                );

            message.channel.send({ embeds: [queueEmbed] });
            break;

        case 'nowplaying':
        case 'np':
            const npQueue = distube.getQueue(message.guild.id);
            if (!npQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            const currentSong = npQueue.songs[0];
            const nowPlayingEmbed = new EmbedBuilder()
                .setTitle('üéµ ƒêang ph√°t')
                .setDescription(`**${currentSong.name}**`)
                .setColor('#00ff00')
                .setThumbnail(currentSong.thumbnail)
                .addFields(
                    { name: 'Th·ªùi l∆∞·ª£ng', value: currentSong.formattedDuration, inline: true },
                    { name: 'Ti·∫øn ƒë·ªô', value: npQueue.formattedCurrentTime, inline: true },
                    { name: 'Ng∆∞·ªùi y√™u c·∫ßu', value: currentSong.user.toString(), inline: true },
                    { name: 'Views', value: currentSong.views?.toLocaleString() || 'N/A', inline: true },
                    { name: 'Volume', value: `${npQueue.volume}%`, inline: true }
                )
                .setURL(currentSong.url);

            message.channel.send({ embeds: [nowPlayingEmbed] });
            break;

        case 'volume':
        case 'vol':
            const volQueue = distube.getQueue(message.guild.id);
            if (!volQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            const volume = parseInt(args[0]);
            if (isNaN(volume) || volume < 0 || volume > 100) {
                return message.reply('‚ùå Volume ph·∫£i l√† s·ªë t·ª´ 0 ƒë·∫øn 100!');
            }

            try {
                distube.setVolume(message.guild.id, volume);
                message.reply(`üîä ƒê√£ ƒë·∫∑t volume th√†nh ${volume}%!`);
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi volume!');
            }
            break;

        case 'pause':
            const pauseQueue = distube.getQueue(message.guild.id);
            if (!pauseQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            if (pauseQueue.paused) {
                distube.resume(message.guild.id);
                message.reply('‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c!');
            } else {
                distube.pause(message.guild.id);
                message.reply('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng ph√°t nh·∫°c!');
            }
            break;

        case 'shuffle':
        case 'mix':
            const shuffleQueue = distube.getQueue(message.guild.id);
            if (!shuffleQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ queue n√†o ƒë·ªÉ tr·ªôn!');
            }

            if (shuffleQueue.songs.length <= 1) {
                return message.reply('‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i trong queue ƒë·ªÉ tr·ªôn!');
            }

            try {
                // Shuffle queue (gi·ªØ b√†i ƒëang ph√°t ·ªü v·ªã tr√≠ ƒë·∫ßu)
                shuffleQueue.shuffle();
                
                const embed = new EmbedBuilder()
                    .setTitle('üîÄ ƒê√£ tr·ªôn queue!')
                    .setDescription(`ƒê√£ tr·ªôn ng·∫´u nhi√™n ${shuffleQueue.songs.length} b√†i h√°t`)
                    .setColor('#ff6b35')
                    .addFields(
                        { name: 'B√†i ti·∫øp theo', value: shuffleQueue.songs[1]?.name || 'Kh√¥ng c√≥', inline: true },
                        { name: 'T·ªïng b√†i', value: `${shuffleQueue.songs.length}`, inline: true }
                    );

                message.channel.send({ embeds: [embed] });
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ tr·ªôn queue!');
            }
            break;

        case 'repeat':
        case 'loop':
            const repeatQueue = distube.getQueue(message.guild.id);
            if (!repeatQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            const mode = args[0];
            let repeatMode;
            let modeText;
            let modeColor;

            if (mode === 'off' || mode === '0') {
                repeatMode = 0;
                modeText = 'T·∫Øt repeat';
                modeColor = '#6c757d';
            } else if (mode === 'song' || mode === '1') {
                repeatMode = 1;
                modeText = 'Repeat b√†i hi·ªán t·∫°i';
                modeColor = '#28a745';
            } else if (mode === 'queue' || mode === '2') {
                repeatMode = 2;
                modeText = 'Repeat to√†n b·ªô queue';
                modeColor = '#007bff';
            } else {
                // Toggle mode n·∫øu kh√¥ng c√≥ tham s·ªë
                repeatMode = (repeatQueue.repeatMode + 1) % 3;
                const modes = ['T·∫Øt repeat', 'Repeat b√†i hi·ªán t·∫°i', 'Repeat to√†n b·ªô queue'];
                const colors = ['#6c757d', '#28a745', '#007bff'];
                modeText = modes[repeatMode];
                modeColor = colors[repeatMode];
            }

            try {
                distube.setRepeatMode(message.guild.id, repeatMode);
                
                const embed = new EmbedBuilder()
                    .setTitle('üîÅ ƒê√£ thay ƒë·ªïi ch·∫ø ƒë·ªô repeat')
                    .setDescription(`**${modeText}**`)
                    .setColor(modeColor)
                    .addFields({
                        name: 'H∆∞·ªõng d·∫´n',
                        value: '`!repeat off/0` - T·∫Øt\n`!repeat song/1` - Repeat b√†i\n`!repeat queue/2` - Repeat queue\n`!repeat` - Chuy·ªÉn ƒë·ªïi',
                        inline: false
                    });

                message.channel.send({ embeds: [embed] });
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi ch·∫ø ƒë·ªô repeat!');
            }
            break;

        case 'autoplay':
            const autoQueue = distube.getQueue(message.guild.id);
            if (!autoQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            try {
                const newAutoplay = !autoQueue.autoplay;
                distube.toggleAutoplay(message.guild.id);
                
                const embed = new EmbedBuilder()
                    .setTitle('üéµ Autoplay')
                    .setDescription(`**${newAutoplay ? 'B·∫≠t' : 'T·∫Øt'} autoplay**`)
                    .setColor(newAutoplay ? '#28a745' : '#6c757d')
                    .addFields({
                        name: 'M√¥ t·∫£',
                        value: newAutoplay ? 
                            'Bot s·∫Ω t·ª± ƒë·ªông th√™m b√†i li√™n quan khi queue h·∫øt' : 
                            'Bot s·∫Ω d·ª´ng khi queue h·∫øt',
                        inline: false
                    });

                message.channel.send({ embeds: [embed] });
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ thay ƒë·ªïi ch·∫ø ƒë·ªô autoplay!');
            }
            break;

        case 'autoshuffle':
            const shuffleAutoQueue = distube.getQueue(message.guild.id);
            if (!shuffleAutoQueue) {
                return message.reply('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
            }

            // Toggle auto-shuffle setting in queue
            shuffleAutoQueue.autoShuffle = !shuffleAutoQueue.autoShuffle;
            
            const embed = new EmbedBuilder()
                .setTitle('üîÄ Auto Shuffle')
                .setDescription(`**${shuffleAutoQueue.autoShuffle ? 'B·∫≠t' : 'T·∫Øt'} auto shuffle**`)
                .setColor(shuffleAutoQueue.autoShuffle ? '#ff6b35' : '#6c757d')
                .addFields({
                    name: 'M√¥ t·∫£',
                    value: shuffleAutoQueue.autoShuffle ? 
                        'Queue s·∫Ω t·ª± ƒë·ªông tr·ªôn l·∫°i sau m·ªói v√≤ng l·∫∑p (khi repeat queue)' : 
                        'T·∫Øt t·ª± ƒë·ªông tr·ªôn queue',
                    inline: false
                })
                .addFields({
                    name: 'Tip',
                    value: 'K·∫øt h·ª£p v·ªõi `!repeat queue` ƒë·ªÉ ph√°t 24/7 v·ªõi th·ª© t·ª± ng·∫´u nhi√™n!',
                    inline: false
                });

            message.channel.send({ embeds: [embed] });
            break;

        case '24h':
        case '24/7':
            const queue247 = distube.getQueue(message.guild.id);
            if (!queue247) {
                return message.reply('‚ùå C·∫ßn c√≥ √≠t nh·∫•t 1 b√†i trong queue tr∆∞·ªõc!');
            }

            if (queue247.songs.length < 2) {
                return message.reply('‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i ƒë·ªÉ thi·∫øt l·∫≠p ph√°t 24/7!');
            }

            // Setup 24/7 mode
            try {
                distube.setRepeatMode(message.guild.id, 2); // Repeat queue
                queue247.shuffle(); // Shuffle ngay
                queue247.autoShuffle = true; // Enable auto shuffle
                
                const embed247 = new EmbedBuilder()
                    .setTitle('üéµ Ch·∫ø ƒë·ªô 24/7 ƒë√£ b·∫≠t!')
                    .setDescription('**Bot s·∫Ω ph√°t nh·∫°c li√™n t·ª•c v·ªõi th·ª© t·ª± ng·∫´u nhi√™n**')
                    .setColor('#00ff00')
                    .addFields(
                        { name: 'üîÅ Repeat Mode', value: 'Queue (L·∫∑p to√†n b·ªô)', inline: true },
                        { name: 'üîÄ Shuffle', value: 'T·ª± ƒë·ªông tr·ªôn m·ªói v√≤ng', inline: true },
                        { name: 'üéµ S·ªë b√†i', value: `${queue247.songs.length}`, inline: true }
                    )
                    .addFields({
                        name: '‚öôÔ∏è Thi·∫øt l·∫≠p ƒë√£ b·∫≠t',
                        value: '‚úÖ Repeat Queue\n‚úÖ Auto Shuffle\n‚úÖ Continuous Play',
                        inline: false
                    })
                    .addFields({
                        name: 'üõë ƒê·ªÉ t·∫Øt',
                        value: '`!stop` ho·∫∑c `!repeat off`',
                        inline: false
                    });

                message.channel.send({ embeds: [embed247] });
            } catch (error) {
                message.reply('‚ùå Kh√¥ng th·ªÉ thi·∫øt l·∫≠p ch·∫ø ƒë·ªô 24/7!');
            }
            break;

        case 'help':
        case 'h':
            const helpEmbed = new EmbedBuilder()
                .setTitle('üéµ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Bot Music')
                .setDescription('**H·ªó tr·ª£ YouTube & Spotify** üé∂')
                .addFields(
                    { name: 'üéµ Ph√°t nh·∫°c', value: `\`${config.prefix}play <URL/T√™n b√†i>\`\nH·ªó tr·ª£: YouTube URL, Spotify URL (songs/playlists), t√¨m ki·∫øm t√™n b√†i`, inline: false },
                    { name: '‚èØÔ∏è ƒêi·ªÅu khi·ªÉn c∆° b·∫£n', value: `\`${config.prefix}skip\` - Skip b√†i hi·ªán t·∫°i\n\`${config.prefix}stop\` - D·ª´ng v√† x√≥a queue\n\`${config.prefix}pause\` - T·∫°m d·ª´ng/ti·∫øp t·ª•c`, inline: false },
                    { name: 'üîÄ ƒêi·ªÅu khi·ªÉn n√¢ng cao', value: `\`${config.prefix}shuffle\` - Tr·ªôn queue ng·∫´u nhi√™n\n\`${config.prefix}repeat [off/song/queue]\` - Ch·∫ø ƒë·ªô l·∫∑p\n\`${config.prefix}autoplay\` - T·ª± ƒë·ªông th√™m b√†i li√™n quan\n\`${config.prefix}autoshuffle\` - T·ª± ƒë·ªông tr·ªôn m·ªói v√≤ng l·∫∑p`, inline: false },
                    { name: 'üéµ Ch·∫ø ƒë·ªô ƒë·∫∑c bi·ªát', value: `\`${config.prefix}24/7\` - **Ph√°t 24/7 v·ªõi tr·ªôn b√†i**\n(T·ª± ƒë·ªông b·∫≠t repeat queue + auto shuffle)`, inline: false },
                    { name: 'üîä √Çm thanh', value: `\`${config.prefix}volume <0-100>\` - ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng`, inline: false },
                    { name: 'üìã Th√¥ng tin', value: `\`${config.prefix}queue\` - Xem queue\n\`${config.prefix}nowplaying\` - B√†i ƒëang ph√°t\n\`${config.prefix}help\` - Menu n√†y`, inline: false },
                    { name: 'üé∂ V√≠ d·ª• Spotify', value: `\`${config.prefix}play https://open.spotify.com/track/...\`\n\`${config.prefix}play https://open.spotify.com/playlist/...\``, inline: false }
                )
                .setColor('#1db954')
                .setFooter({ text: 'Bot Music Discord - YouTube & Spotify Support' });

            message.channel.send({ embeds: [helpEmbed] });
            break;

        default:
            message.reply(`‚ùå L·ªánh kh√¥ng t·ªìn t·∫°i! S·ª≠ d·ª•ng \`${config.prefix}help\` ƒë·ªÉ xem danh s√°ch l·ªánh.`);
    }
});

// X·ª≠ l√Ω l·ªói
client.on('error', error => {
    console.error('Discord client error:', error);
});

process.on('unhandledRejection', error => {
    console.error('Unhandled promise rejection:', error);
});

// ƒêƒÉng nh·∫≠p bot
client.login(config.token).catch(error => {
    console.error('‚ùå Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p bot! Ki·ªÉm tra l·∫°i token:', error);
    process.exit(1);
});
